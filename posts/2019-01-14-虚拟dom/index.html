<!DOCTYPE html>
<html lang="zh-Hans-CN">
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		
		<meta name="author" content="Simeon">
		<meta name="description" content="Simeon 个人微博">
		<meta name="generator" content="Hugo 0.52" />
		<title>虚拟DOM &middot; Simeon&#39;s blog</title>
		<link rel="shortcut icon" href="https://simeon49.github.io/blog/images/favicon.ico">
		<link rel="stylesheet" href="https://simeon49.github.io/blog/css/style.css">
		<link rel="stylesheet" href="https://simeon49.github.io/blog/css/highlight.css">

		
		<link rel="stylesheet" href="https://simeon49.github.io/blog/css/font-awesome.min.css">
		

		

		
	</head>

    <body>
       <nav class="main-nav">
	
	
		<a href='https://simeon49.github.io/blog/'> <span class="arrow">←</span>Home</a>
	
	<a href='https://simeon49.github.io/blog/posts'>Archive</a>
	<a href='https://simeon49.github.io/blog/tags'>Tags</a>
	<a href='https://simeon49.github.io/blog/categories'>Categories</a>
	<a href='https://simeon49.github.io/blog/about'>About</a>

	

	
</nav>


        <section id="wrapper" class="post">
            <article>
                <header>
                    <h1>
                        虚拟DOM
                    </h1>
                    <h2 class="headline">
                    Jan 14, 2019 00:00
                    · 1632 words
                    · 4 minute read
                      <span class="tags">
                      
                      
                          
                              <a href="https://simeon49.github.io/blog/tags/js">js</a>
                          
                      
                      
                      </span>
                    </h2>
                </header>
                
                <section id="post-body">
                    

<h2 id="什么是虚拟dom">什么是虚拟DOM</h2>

<p>前端的DOM操作是一个非常消耗性能的事, 因为每一个DOM元素对象拥有很多的属性</p>

<pre><code class="language-js">const divDom = document.createElement('div');
for (let key in divDom) {
    console.log(key);   // 大概可以打印出200+多个属性
}
</code></pre>

<p>在页面元素不多的情况下, 可以使用innHTML将我们想要显示的内容替换到页面上:</p>

<pre><code class="language-html">&lt;body&gt;
    &lt;header&gt;虚拟Dom实例:&lt;/header&gt;
    &lt;div id=&quot;anchor&quot; class=&quot;container&quot;&gt;
        &lt;p&gt;同学录: &lt;/p&gt;
        &lt;div class=&quot;list&quot;&gt;
            &lt;div&gt;&lt;p&gt;Name: Jack&lt;/p&gt;&lt;p&gt;Adge: 12&lt;/p&gt;&lt;/div&gt;
            &lt;div&gt;&lt;p&gt;Name: Tom&lt;/p&gt;&lt;p&gt;Adge: 14&lt;/p&gt;&lt;/div&gt;
        &lt;/div&gt;
    &lt;div&gt;

    &lt;script&gt;
        const anchorDom = document.getElementById('anchor');
        setTimeout(() =&gt; {
            anchorDom.innerHTML = `
                &lt;p&gt;同学录: &lt;/p&gt;
                &lt;div class=&quot;list&quot;&gt;
                    &lt;div class=&quot;active&quot;&gt;&lt;p&gt;Name: Jack&lt;/p&gt;&lt;p&gt;Adge: 12&lt;/p&gt;&lt;/div&gt;
                    &lt;div&gt;&lt;p&gt;Name: Tom&lt;/p&gt;&lt;p&gt;Adge: 14&lt;/p&gt;&lt;/div&gt;
                &lt;/div&gt;
            `;
        }, 5000);
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>

<p>这样页面上有一个id为anchor的锚点元素,里面有2个子元素, 5s后将第一个子元素的class更新为&rdquo;active&rdquo;, 这样做在内容较少或更新周期较长的情况下不会有什么性能问题. 但想想一下如果anchor包含上千个子元素, 这样的更新会使用户等待很长时间才能看到更新结果, 事实上前端主要的一部分工作就是维护状态并在状态变化时更新对应的视图 例如我在另一篇文章介绍的<a href="https://simeon49.github.io/blog/posts/2018-12-29-简单的前端mvc实现/">MVC</a>. 页面的更新通常是频繁而复杂的.</p>

<p><strong>虚拟DOM:</strong> 就是为了减少DOM的操作, 比如前面更新anchor的操作, 使用虚拟DOM操作后将会只更新修改部分的视图内容</p>

<pre><code class="language-html">&lt;div class=&quot;active&quot;&gt;&lt;p&gt;Name: Jack&lt;/p&gt;&lt;p&gt;Adge: 12&lt;/p&gt;&lt;/div&gt;
</code></pre>

<p>它的原理也很简单, 首先将一个页面抽象成一个js Tree:</p>

<pre><code class="language-js">    const tree = new VElement('div', [
        new VElement('p', ['同学录: ']),
        new VElement('div', {'class': 'list'}, [
            new VElement('div', {'key': 'id_01'}, [ // key: 的作用是帮助虚拟DOM区分不同的子元素
                new VElement('p', ['Name: Jack'],
                new VElement('p', ['Adge: 12']))
            ]),
            new VElement('div', {'key': 'id_02'}, [
                new VElement('p', ['Name: Tom'],
                new VElement('p', ['Adge: 14']))
            ])
        ]),
    ]);

    const dom = tree.render();  // 生成 dom
    document.getElementById('anchor').appendChild(dom);
</code></pre>

<p>当页面发生变化时, 生成 newTree</p>

<pre><code class="language-js">    const newTree = new VElement('div', [
        new VElement('p', ['同学录: ']),
        new VElement('div', {'class': 'list'}, [
            new VElement('div', {'key': 'id_01', 'class': 'active'}, [ // 注意: key要与之前的结构对应
                new VElement('p', ['Name: Jack'],
                new VElement('p', ['Adge: 12']))
            ]),
            new VElement('div', {'key': 'id_02'}, [
                new VElement('p', ['Name: Tom'],
                new VElement('p', ['Adge: 14']))
            ])
        ]),
    ]);
</code></pre>

<p>比较 newTree 相对 tree js结构变化生成变化补丁:</p>

<pre><code class="language-js">    const patchDic = diff(tree, newTree);
    console.log(patchDic);
    // 打印结果如下
    // {
    //     4: { type: &quot;PROPOS&quot;, props: { class: &quot;active&quot; }}
    // }
    // 4: 代表 深度遍历tree的第4个节点
    // type: 表示: 该节点的更新是&quot;属性&quot;更新,
    // props: 表示: 变更的属性是 &quot;class&quot; 对应的值是 &quot;active&quot;
</code></pre>

<p>最后将变化的部分,应用到tree上, 这样 tree 就与 newTree 拥有同样的DOM结构</p>

<pre><code class="language-js">    updatePatch(tree, patchDic);
</code></pre>

<h2 id="原理">原理:</h2>

<p>从上面的过程不难看出 虚拟dom的4个过程:</p>

<ul>
<li>1.抽象html -&gt; js tree结构</li>
<li>2.抽象变化后的html -&gt; js newTree结构</li>
<li>3.比较两棵树的变化 生成patchDic</li>
<li>4.在tree上应用 patchDic 使得 tree与 newTree有相同的Dom结构</li>
</ul>

<p>步骤1,2 的代码实现:</p>

<pre><code class="language-js">class VElement {
  /**
   * @param {*} tagName 标签名
   * @param {*} props 属性
   * @param {*} children 子元素
   */
  constructor(tagName, props, children) {
    this.tagName = tagName;
    if (props instanceof Array) {
      children = props;
      props = {};
    }
    this.props = props || {};
    this.children = children || [];
    this.key = this.props.key;

    let count = 0;
    this.children.forEach(child =&gt; {
      if (child instanceof VElement) {
        count += child.childrenCount;
      } else {
        child = '' + child;
      }
      count ++;
    });
    this.childrenCount = count;
    this.dom = null
  }

  /**
   * 通过js tree结构 -&gt; 真实的DOM
   */
  render() {
    const dom = document.createElement(this.tagName);
    for (const k in this.props) {
      dom.setAttribute(k, this.props[k]);
    }

    this.children.forEach(child =&gt; {
      const node = child instanceof VElement ? child.render() : document.createTextNode(child);
      dom.appendChild(node);
    });
    this.dom = dom;
    return this.dom;
  }
}
</code></pre>

<p>步骤3 是整个虚拟DOM的核心</p>

<pre><code class="language-js">/**
 * 判断两个节点是否为相同的节点, 为节点添加 key 值将有助于虚拟DOM判断节点是否是同一节点
 * @param {*} oldNode
 * @param {*} newNode
 */
function isSameNode(oldNode, newNode) {
  return oldNode.tagName === newNode.tagName &amp;&amp; oldNode.key === newNode.key;
}

/**
 * diff
 * @param {*} oldNode
 * @param {*} newNode
 */
function diff(oldNode, newNode) {
  const patchDic = {};
  computeNodeChange(oldNode, newNode, 0, patchDic);
  return patchDic;
}

/**
 * 计算节点变化
 * @param {*} oldNode
 * @param {*} newNode
 * @param {*} oldIndex
 * @param {*} patchDic
 */
function computeNodeChange(oldNode, newNode, oldIndex, patchDic) {
  const curPatchs = [];
  // 相同节点
  if (isSameNode(oldNode, newNode)) {
    // 计算节点属性差异
    computePropsChange(oldNode, newNode, curPatchs);

    // 计算子节点差异
    computeChildrenChange(oldNode, newNode, curPatchs, oldIndex, patchDic);
  }
  if (curPatchs.length) {
    patchDic[oldIndex] = curPatchs;
  }
}

function computePropsChange(oldNode, newNode, curPatchs) {
    ...
}

function computeChildrenOrderChange(oldCh, newCh) {
    ...
}
</code></pre>

<p>computeChildrenOrderChange 的实现参考了 vue, 算法的复杂度接近O(n), 具体可以参考这篇<a href="https://juejin.im/post/5ad6182df265da23906c8627">文章</a></p>

<p>步骤4 的实现代码</p>

<pre><code class="language-js">/**
 * 更新节点变化(深度遍历)
 * @param {*} oldNode
 * @param {*} patchDic
 */
function updatePatch(oldNode, patchDic) {
  walkPatch(oldNode, patchDic, 0);
}

function walkPatch(node, patchDic, index) {
  const patchs = patchDic[index];
  if (patchs) {
    for (let i = 0; i &lt; patchs.length; i++) {
      const patch = patchs[i];
      doPatch(node, patch);
    }
  }
  index += 1;
  if (node.children) {
    for (let i = 0; i &lt; node.children.length; i++) {
      index = walkPatch(node.children[i], patchDic, index);

    }
  }
  return index;
}

/**
 * 执行更新操作
 * @param {*} node
 * @param {*} patch
 */
function doPatch(node, patch) {
  switch (patch.type) {
    case 'PROPOS':
      for (let key in patch.props) {
        const value = patch.props[key];
        if (value) {
          node.dom.setAttribute(key, value);
        } else {
          node.dom.removeAttribute(key);
        }
      }
      break;
    case 'CHILDREN':
      patch.steps.forEach(step =&gt; {
        const method = step.method
          , domCh = node.dom.childNodes
          , nodeCh = node.children;

        if (method === 'MOVE_TO_END') {
          node.dom.append(domCh[step.index]);
          nodeCh.push(nodeCh.splice(step.index, 1)[0]);
        } else if (method === 'MOVE_BEFORE') {
          node.dom.insertBefore(domCh[step.index], domCh[step.before]);
          nodeCh.splice(step.before, 0, nodeCh.splice(step.index, 1)[0]);
        } else if (method === 'INSERT_END') {
          const n = step.node instanceof VElement ? step.node.render() : document.createTextNode('' + step.node);
          node.dom.append(n);
          nodeCh.push(step.node);
        } else if (method === 'INSERT_BEFOR') {
          const n = step.node instanceof VElement ? step.node.render() : document.createTextNode('' + step.node);
          node.dom.insertBefore(n, domCh[step.before]);
          nodeCh.splice(step.before, 0, step.node);
        } else if (method === 'REMOVE') {
          try {
            node.dom.removeChild(domCh[step.index]);
            nodeCh.splice(step.index, 1);
          } catch (error) {
            window['node'] = node;
            window['step'] = step;
            throw error;
          }
        } else {
          console.error(`unknow method '${method}'`);
        }
      });
      break;
    default:
      break;
  }
}
</code></pre>

<p>直接看<a href="https://github.com/simeon49/javascript-practices/tree/master/project_07_虚拟DOM">源码</a> <br>
直接看<a href="https://simeon49.github.io/javascript-practices/project_07_虚拟DOM/index.html">Demo</a> <br></p>

                </section>
            </article>

            

            
                <div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'simeon49';

     
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';

        
        var disquesLoaded = false;
        dsq.onload = function () {
            disquesLoaded = true;
        };
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);

        setTimeout(() => {
            if (!disquesLoaded) {
                alert('加载disques 失败!');
            }
        }, 3000);

    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>

            

            
                <ul id="post-list" class="archive readmore">
    <h3>Read more</h3>

    
    
    
        <li>
            <a href="/blog/posts/2019-01-22-%E4%BB%8E%E8%BE%93%E5%85%A5url%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E5%88%B0%E5%BA%95%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/">从输入url到页面展示到底发生了什么<aside class="dates">Jan 22 2019</aside></a>
        </li>
    
        <li>
            <a href="/blog/posts/2019-01-16-%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/">浏览器缓存<aside class="dates">Jan 16 2019</aside></a>
        </li>
    
        <li>
            <a href="/blog/posts/2019-01-15-%E4%B8%80%E9%81%93%E7%A5%9E%E5%A5%87%E7%9A%84%E5%89%8D%E7%AB%AF%E9%99%84%E5%8A%A0%E9%A2%98/">一道神奇的前端附加题<aside class="dates">Jan 15 2019</aside></a>
        </li>
    
        <li>
            <a href="/blog/posts/2018-12-29-%E7%AE%80%E5%8D%95%E7%9A%84%E5%89%8D%E7%AB%AFmvc%E5%AE%9E%E7%8E%B0/">简单的前端MVC实现<aside class="dates">Dec 29 2018</aside></a>
        </li>
    
        <li>
            <a href="/blog/posts/2018-12-28-js%E4%B8%AD%E7%9A%84object.defineproperty/">js中的神奇方法Object.defineProperty<aside class="dates">Dec 28 2018</aside></a>
        </li>
    
        <li>
            <a href="/blog/posts/2018-12-28-%E4%BD%BF%E7%94%A8web_api%E5%A4%84%E7%90%86%E5%9B%BE%E7%89%87/">使用web_API处理图片<aside class="dates">Dec 24 2018</aside></a>
        </li>
    
        <li>
            <a href="/blog/posts/2018-12-24-%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E5%8E%9F%E7%90%86/">数字签名原理<aside class="dates">Dec 24 2018</aside></a>
        </li>
    
</ul>

            

            <footer id="footer">
    
        <div id="social">

	
	
    <a class="symbol" href="https://github.com/simeon49">
        <i class="fa fa-github-square"></i>
    </a>
    


</div>

    
    <p class="small">
    
       © Copyright 2019 <i class="fa fa-heart" aria-hidden="true"></i> Simeon
    
    </p>
    
</footer>

        </section>

        <script src="https://simeon49.github.io/blog/js/jquery-3.3.1.min.js"></script>
<script src="https://simeon49.github.io/blog/js/main.js"></script>
<script src="https://simeon49.github.io/blog/js/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>






<script>
var baiduAnalytics = '74fafdde017951e1df78c761e7c017bc';
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?" + baiduAnalytics;
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>


    </body>
</html>
