<!DOCTYPE html>
<html lang="zh-Hans-CN">
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		
		<meta name="author" content="Simeon">
		<meta name="description" content="Simeon 个人微博">
		<meta name="generator" content="Hugo 0.52" />
		<title>数据库内容复习02-MySql的索引们 &middot; Simeon&#39;s blog</title>
		<link rel="shortcut icon" href="https://simeon49.github.io/blog/images/favicon.ico">
		<link rel="stylesheet" href="https://simeon49.github.io/blog/css/style.css">
		<link rel="stylesheet" href="https://simeon49.github.io/blog/css/highlight.css">

		
		<link rel="stylesheet" href="https://simeon49.github.io/blog/css/font-awesome.min.css">
		

		

		
	</head>

    <body>
       <nav class="main-nav">
	
	
		<a href='https://simeon49.github.io/blog/'> <span class="arrow">←</span>Home</a>
	
	<a href='https://simeon49.github.io/blog/posts'>Archive</a>
	<a href='https://simeon49.github.io/blog/tags'>Tags</a>
	<a href='https://simeon49.github.io/blog/categories'>Categories</a>
	<a href='https://simeon49.github.io/blog/about'>About</a>

	

	
</nav>


        <section id="wrapper" class="post">
            <article>
                <header>
                    <h1>
                        数据库内容复习02-MySql的索引们
                    </h1>
                    <h2 class="headline">
                    Feb 28, 2019 00:00
                    · 2074 words
                    · 5 minute read
                      <span class="tags">
                      
                      
                          
                              <a href="https://simeon49.github.io/blog/tags/%E6%95%B0%E6%8D%AE%E5%BA%93">数据库</a>
                          
                              <a href="https://simeon49.github.io/blog/tags/sql">SQL</a>
                          
                              <a href="https://simeon49.github.io/blog/tags/mysql">MySql</a>
                          
                              <a href="https://simeon49.github.io/blog/tags/%E7%B4%A2%E5%BC%95">索引</a>
                          
                              <a href="https://simeon49.github.io/blog/tags/%E4%B8%BB%E9%94%AE">主键</a>
                          
                              <a href="https://simeon49.github.io/blog/tags/%E5%85%A8%E6%96%87%E7%B4%A2%E5%BC%95">全文索引</a>
                          
                      
                      
                      </span>
                    </h2>
                </header>
                
                <section id="post-body">
                    

<p>复习数据库方面的内容, 以下为笔记内容, 参考了:<br>
[<a href="https://www.jianshu.com/p/dd4fe101cffe">关于索引的-1</a><br>
<a href="https://blog.csdn.net/gengfu_php/article/details/72614867">关于索引的-2</a><br>
<a href="https://n.sfs.tw/content/index/11465?noframe=true">全文检索</a><br>
<a href="https://segmentfault.com/q/1010000005715926">全文搜索无结果原因</a>]<br>
<a href="https://blog.csdn.net/sweeper_freedoman/article/details/61426736">外键</a><br>
&hellip;</p>

<h3 id="索引">索引</h3>

<p>索引是用来快速的寻找具有特定值的记录, 提高检索效率, 但同时需要额外的空间存储这些索引, 并在进行插入,修改和删除操作时需要对索引进行维护.</p>

<h4 id="普通索引-index">普通索引(Index):</h4>

<p>普通索引的唯一作用是: 提高数据检索效率.</p>

<p><strong>创建</strong></p>

<pre><code class="language-SQL">-- 方法一:
CREATE TABLE `table-name` (
    -- ...
    `column` VARCHAR(100),
    -- ...
    KEY `index-name` (`column`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- 方法二:
ALTER TABLE `table-name` ADD INDEX `index-name`(`column`);

-- 联合索引:
ALTER TABLE `table-name` ADD INDEX `index-name`(`column-1`, `column-2`, `column-3`);
</code></pre>

<p><strong>删除</strong></p>

<pre><code class="language-SQL">ALTER TABLE `table-name` DROP INDEX `index-name`;
</code></pre>

<blockquote>
<p><code>使用建议:</code><br>
应该只对那些经常出现在查询条件(WHERE column=)或者排序条件(ORDERBY column) 中对应的column建立索引</p>
</blockquote>

<h4 id="唯一索引-unique">唯一索引(Unique):</h4>

<p>唯一索引属于普通索引, 如果确定某个数据列只包含彼此不同的值, 就应该把对应的column设置为唯一索引</p>

<p><strong>创建</strong></p>

<pre><code class="language-SQL">-- 方法一:
CREATE TABLE `table-name` (
    -- ...
    `column` VARCHAR(100),
    -- ...
    UNIQUE KEY `index-name` (`column`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- 方法二:
ALTER TABLE `table-name` ADD  UNIQUE INDEX `index-name`(`column`);

-- 联合索引:
ALTER TABLE `table-name` ADD  UNIQUE INDEX `index-name`(`column-1`, `column-2`, `column-3`);
</code></pre>

<p><strong>删除</strong></p>

<pre><code class="language-SQL">ALTER TABLE `table-name` DROP INDEX `index-name`;
</code></pre>

<h4 id="主键-primary-key">主键(Primary Key):</h4>

<p>主键用于唯一鉴定唯一的一行记录, 区别于唯一索引:
- 不能有NULL(空)值
- 一张表最多只能有一个主键, 但可以很多个索引
- 主键可以作为外键, 唯一索引不可以</p>

<p><strong>创建</strong></p>

<pre><code class="language-SQL">-- 方法一:
CREATE TABLE `table-name` (
    -- ...
    `column` INT NOT NULL,
    -- ...
    PRIMARY KEY (`column`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- 方法二:
ALTER TABLE `table-name` ADD CONSTRAINT `pk-name` PRIMARY KEY (`column`);

-- 多列做为主键:
ALTER TABLE `table-name` ADD CONSTRAINT `pk-name` PRIMARY KEY(`column-1`, `column-2`, `column-3`);
</code></pre>

<p><strong>删除</strong></p>

<pre><code class="language-SQL">ALTER TABLE `table-name` DROP PRIMARY KEY;
</code></pre>

<h3 id="全文索引-fulltext">全文索引(FullText)</h3>

<p>还记得 SELECT * FROM <code>table-name</code> where <code>title</code> like &lsquo;%中文%&rsquo; 吗?
全文索引比它效率高的多.</p>

<p><strong>创建</strong></p>

<pre><code class="language-SQL">-- 方法一:
CREATE TABLE `table-name` (
    `id` int(11) NOT NULL AUTO_INCREMENT,
    `title` varchar(200) DEFAULT NULL,
    `content` text,
    PRIMARY KEY (`id`),
    FULLTEXT KEY `ft-name` (`title`, `content`) with parser ngram
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- 方法二: 注意: ngram 是支持中文的分词器, 如果不设置这个分词器, 检索时将按照英文的分词习惯分词(中文将检索不到结果)
ALTER TABLE `table-name` ADD FULLTEXT `ft-name` (`title`, `content`) with parser ngram;
</code></pre>

<p><strong>使用</strong></p>

<pre><code class="language-SQL">-- 先插入几条数据
insert into `table-name` (title, content) values('英文索引', '分词，全文索引以词为基础的，MySQL默认的分词是所有非字母和数字的特殊符号都是分词符)');
insert into `table-name` (title, content) values('中文索引', '分词，全文索引以词为基础的，MySQL默认的分词是所有非字母和数字的特殊符号都是分词符)');
insert into `table-name` (title, content) values('日文索引', '分词，全文索引以词为基础的，MySQL默认的分词是所有非字母和数字的特殊符号都是分词符)');

SELECT * FROM `table-name` WHERE `title` LIKE '%索引%';
-- 检索出3条

-- 注意MATCH里的字段必须与&quot;FULLTEXT KEY `ft-name` (`title`, `content`)&quot;中的一样, 不然会报错 (1191, &quot;Can't find FULLTEXT index matching the column list&quot;)
SELECT title FROM `table-name` WHERE MATCH(`title`, `content`) AGAINST('索引');
-- 检索出3条

SELECT title FROM `table-name` WHERE MATCH(`title`, `content`) AGAINST('索');
-- 检索出0条; 因为检索是按分词的方式检索 &quot;索引&quot;是一个词, &quot;所&quot;不是

SELECT title FROM `table-name` WHERE MATCH(`title`, `content`) AGAINST('索' IN BOOLEAN MODE);
</code></pre>

<p><strong>使用Boolean mode 来检索</strong></p>

<table>
<thead>
<tr>
<th align="center">关键字</th>
<th align="center">说明</th>
<th align="center">实例</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">+word</td>
<td align="center">记录中一定要有这个词</td>
<td align="center">AGAINST(&lsquo;+中文 +分词&rsquo; IN BOOLEAN MODE)</td>
</tr>

<tr>
<td align="center">-word</td>
<td align="center">记录中一定不要有这个词</td>
<td align="center">AGAINST(&lsquo;-中文 +分词&rsquo; IN BOOLEAN MODE)</td>
</tr>

<tr>
<td align="center">?word</td>
<td align="center">记录中不应该有这个词, 但有可以有, 降低该词的权重</td>
<td align="center">AGAINST(&lsquo;?中文 +分词&rsquo; IN BOOLEAN MODE)</td>
</tr>

<tr>
<td align="center">key*</td>
<td align="center">记录中以key开头的词</td>
<td align="center">AGAINST(&lsquo;?中文 +分词&rsquo; IN BOOLEAN MODE)</td>
</tr>

<tr>
<td align="center">()</td>
<td align="center">分组: 一定有&rdquo;分词&rdquo; 以及(&ldquo;中文&rdquo; 或 &ldquo;英文&rdquo;)</td>
<td align="center">AGAINST(&lsquo;+分词 +(中文 英文)&rsquo; IN BOOLEAN MODE)</td>
</tr>
</tbody>
</table>

<p><strong>删除</strong></p>

<pre><code class="language-SQL">ALTER TABLE `table-name` DROP INDEX `ft-name`;
</code></pre>

<blockquote>
<p><code>建议</code>:<br>
如果对此检索有更高的要求, 建议使用全文搜索引擎比如: <a href="http://sphinxsearch.com/">sphinx</a></p>
</blockquote>

<h4 id="外键-foreign-key">外键(Foreign Key):</h4>

<p>没有找到好的解释, 简单的说就是一张子表关联到另一张父表的一种有效的方法(用来建立两个表格之间关系的约束)(有些牵强&hellip;)
外键值可以为空, 但不能存在子表对应字段数据在关联父表记录找不到的情况</p>

<p><strong>创建</strong></p>

<pre><code class="language-SQL">CREATE TABLE `tab_father` (
    `pk_left` INT(11) UNSIGNED NOT NULL,
    `pk_right` INT(11) UNSIGNED NOT NULL,
    `ts` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
) ENGINE=InnoDB;
ALTER TABLE `tab_father` ADD INDEX `pk_right` (`pk_right`); -- 被关联键可以是主键,唯一索引,普通索引,联合索引(必须为最左值),

CREATE TABLE `tab_child` (
    `id` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,
    `col` INT(10) UNSIGNED NOT NULL,
    PRIMARY KEY (`id`)
) ENGINE=InnoDB;

-- 方法一:
ALTER TABLE `tab_child` ADD CONSTRAINT `FK_tab_child_tab_father` FOREIGN KEY (`column`) REFERENCES `tab_father` (`pk_right`) ON UPDATE CASCADE ON DELETE CASCADE;
</code></pre>

<blockquote>
<p>关于外键创建的条件:<br>
如果（父表）字段没有索引，创建外键会失败, 父表关联字段必须显式创建索引（单字段索引或位于最左位置的组合索引）；子表外键字段也是索引字段（如果不是索引字段建立外键关系的时候MySQL会隐式地为该字段创建一个普通索引）。即外键相关字段最后一定会是索引字段。参考<a href="https://blog.csdn.net/sweeper_freedoman/article/details/61426736">论证过程</a></p>
</blockquote>

<p><strong>删除</strong></p>

<pre><code class="language-SQL">ALTER TABLE `tab_child` DROP FOREIGN KEY `FK_tab_child_tab_father`;
</code></pre>

<p><strong>在高并发系统中其实很少使用外键, 对于并发小的系统中, 外键常在以下几种情况中被使用:</strong></p>

<ul>
<li><p>有关联关系的表:</p>

<ul>
<li>一对一</li>
<li>一对多:</li>
<li>多对多: 这种情况需要建立一张中间表, 比如: 一个老师会教不同的班级, 一个班级又有很多不同的老师, 此时可以建一张中间表 teacher_class(id, teacher_id, class_id)</li>
</ul></li>

<li><p>优化查询速度:
有时候在一张表中有很多的字段, 有些字段在大多数的时候很好少被使用, 另一些字段却常常被使用, 比如: 一个用户信息表中 user(id, name, paswd, address, hobbies&hellip;) [id, name, paswd] 会被经常使用, [address, hobbies] 很少被使用, 此时可以将user差分为 user_info(id, name, paswd) user_profile(user_id, address, hobbies)</p></li>
</ul>

<h3 id="补充">补充:</h3>

<p>查询数据表的结构</p>

<pre><code class="language-SQL">SHOW CREATE TABLE `tab_name`\G;
</code></pre>

                </section>
            </article>

            

            
                <div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'simeon49';

     
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';

        
        var disquesLoaded = false;
        dsq.onload = function () {
            disquesLoaded = true;
        };
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);

        setTimeout(() => {
            if (!disquesLoaded) {
                alert('加载disques 失败!');
            }
        }, 3000);

    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>

            

            
                <ul id="post-list" class="archive readmore">
    <h3>Read more</h3>

    
    
    
        <li>
            <a href="/blog/posts/2019-04-12-web-component/">web-component<aside class="dates">Apr 12 2019</aside></a>
        </li>
    
        <li>
            <a href="/blog/posts/2019-03-11-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A006-mysql%E7%9A%84%E4%BC%98%E5%8C%96%E5%8E%9F%E7%90%86/">数据库内容复习06-MySql的优化原理<aside class="dates">Mar 11 2019</aside></a>
        </li>
    
        <li>
            <a href="/blog/posts/2019-03-06-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A005-mysql%E7%9A%84%E4%BA%8B%E5%8A%A1/">数据库内容复习05-MySql的事务<aside class="dates">Mar 6 2019</aside></a>
        </li>
    
        <li>
            <a href="/blog/posts/2019-03-05-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A004-mysql%E7%9A%84%E5%85%B6%E5%AE%83%E6%93%8D%E4%BD%9C/">数据库内容复习04-MySql的其它操作<aside class="dates">Mar 5 2019</aside></a>
        </li>
    
        <li>
            <a href="/blog/posts/2019-03-04-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A003-mysql%E7%9A%84%E6%9F%A5%E8%AF%A2/">数据库内容复习03-MySql的查询<aside class="dates">Mar 4 2019</aside></a>
        </li>
    
        <li>
            <a href="/blog/posts/2019-02-26-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A001-%E6%A6%82%E8%BF%B0/">数据库内容复习01-概述<aside class="dates">Feb 26 2019</aside></a>
        </li>
    
        <li>
            <a href="/blog/posts/2019-02-12-%E5%BC%80%E6%BA%90%E8%AE%B8%E5%8F%AF%E8%AF%81gplbsdmitmozillaapache%E5%92%8Clgpl%E7%9A%84%E5%8C%BA%E5%88%AB/">开源许可证GPL、BSD、MIT、Mozilla、Apache和LGPL的区别<aside class="dates">Feb 12 2019</aside></a>
        </li>
    
        <li>
            <a href="/blog/posts/2019-01-26-%E4%BC%98%E7%BE%8E%E4%BB%A3%E7%A0%81-%E5%8E%9F%E5%9E%8B/">优美代码-原型<aside class="dates">Jan 26 2019</aside></a>
        </li>
    
        <li>
            <a href="/blog/posts/2019-01-25-%E4%BC%98%E7%BE%8E%E4%BB%A3%E7%A0%81-%E6%AD%A3%E4%BA%A4/">优美代码-正交<aside class="dates">Jan 25 2019</aside></a>
        </li>
    
        <li>
            <a href="/blog/posts/2019-01-24-%E4%BC%98%E7%BE%8E%E4%BB%A3%E7%A0%81-%E4%BD%BF%E7%94%A8%E5%86%97%E4%BD%99%E5%AD%97%E6%AE%B5%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98/">优美代码-使用冗余字段处理问题<aside class="dates">Jan 24 2019</aside></a>
        </li>
    
</ul>

            

            <footer id="footer">
    
        <div id="social">

	
	
    <a class="symbol" href="https://github.com/simeon49">
        <i class="fa fa-github-square"></i>
    </a>
    


</div>

    
    <p class="small">
    
       © Copyright 2019 <i class="fa fa-heart" aria-hidden="true"></i> Simeon
    
    </p>
    
</footer>

        </section>

        <script src="https://simeon49.github.io/blog/js/jquery-3.3.1.min.js"></script>
<script src="https://simeon49.github.io/blog/js/main.js"></script>
<script src="https://simeon49.github.io/blog/js/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>






<script>
var baiduAnalytics = '74fafdde017951e1df78c761e7c017bc';
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?" + baiduAnalytics;
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>


    </body>
</html>
